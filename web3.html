<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Propositional Logic Parser</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
        }

        h2 {
            color: #666;
            margin-top: 0;
        }

        input,
        textarea {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            box-sizing: border-box;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #45a049;
        }

        .output {
            background: #f9f9f9;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #4CAF50;
            font-family: monospace;
            white-space: pre-wrap;
        }

        .error {
            border-left-color: #f44336;
            background: #ffebee;
        }

        .info {
            border-left-color: #2196F3;
            background: #e3f2fd;
        }

        .examples button {
            background: #2196F3;
            font-size: 12px;
            padding: 8px 12px;
        }

        .examples button:hover {
            background: #1976D2;
        }
    </style>
</head>

<body>
    <h1>Propositional Logic Parser</h1>

    <div class="container">
        <p><strong>Operators:</strong> <code>~</code> (NOT), <code>+</code> (OR), <code>*</code> (AND), <code>></code>
            (IMPLIES)</p>
        <p><strong>Note:</strong> Formulas must be fully parenthesized. Example: ((p+q)*r)</p>
    </div>

    <div class="container examples">
        <h2>Quick Examples</h2>
        <button onclick="loadExample('(p+q)')">Simple OR</button>
        <button onclick="loadExample('(p*q)')">Simple AND</button>
        <button onclick="loadExample('(~p)')">Negation</button>
        <button onclick="loadExample('(p>q)')">Implication</button>
        <button onclick="loadExample('((p+q)*r)')">Complex 1</button>
        <button onclick="loadExample('((p>q)*(~r))')">Complex 2</button>
    </div>

    <div class="container">
        <h2>Build Parse Tree</h2>
        <label>Enter Infix Formula:</label>
        <input type="text" id="infixInput" placeholder="e.g., ((p+q)*r)" value="((p+q)*r)">
        <button onclick="buildTree()">Build Parse Tree</button>
        <button onclick="convertToPrefix()">Convert to Prefix</button>
        <div id="output" class="output info">Enter a formula and click "Build Parse Tree"</div>
    </div>

    <div class="container">
        <h2>Tree Operations</h2>
        <button onclick="showInfix()">Show Infix</button>
        <button onclick="showPrefix()">Show Prefix</button>
        <button onclick="showHeight()">Show Height</button>
        <button onclick="showStructure()">Show Structure</button>
        <div id="treeOutput" class="output info">Build a tree first</div>
    </div>

    <div class="container">
        <h2>CNF Conversion</h2>
        <button onclick="convertToCNF()">Convert to CNF</button>
        <div id="cnfOutput" class="output info">Build a tree first</div>
    </div>

    <div class="container">
        <h2>Evaluate Formula</h2>
        <div id="evalInputs"></div>
        <button onclick="evaluateFormula()">Evaluate</button>
        <button onclick="printTruthTable()">Print Truth Table</button>
        <div id="evalOutput" class="output info">Build a tree first</div>
    </div>

    <div class="container">
        <h2>DIMACS Format</h2>
        <button onclick="convertToDIMACS()">Convert to DIMACS</button>
        <button onclick="downloadDIMACS()">Download CNF File</button>
        <br><br>
        <label>Load DIMACS:</label>
        <textarea id="dimacsInput" rows="5" placeholder="p cnf 3 2&#10;1 -2 0&#10;-1 3 0"></textarea>
        <button onclick="parseDIMACS()">Parse DIMACS</button>
        <button onclick="checkDIMACSValidity()">Check DIMACS Validity</button>
        <button onclick="dimacsToInfix()">Convert DIMACS to Infix</button>
        <div id="dimacsOutput" class="output info">DIMACS operations appear here</div>
    </div>

    <script>
        // Global state
        let currentTree = null;
        let currentCNFTree = null;
        let variableMapping = {};
        let reverseMapping = {};
        let nextVarId = 1;

        // Node class
        class Node {
            constructor(value, left = null, right = null) {
                this.value = value;
                this.left = left;
                this.right = right;
            }

            isLeaf() {
                return !this.left && !this.right;
            }

            clone() {
                return new Node(
                    this.value,
                    this.left ? this.left.clone() : null,
                    this.right ? this.right.clone() : null
                );
            }
        }

        // Parse infix formula
        function parseInfix(formula) {
            formula = formula.replace(/\s+/g, '');
            let index = 0;

            function parse() {
                if (index >= formula.length) {
                    throw new Error('Unexpected end of formula');
                }

                if (formula[index] === '(') {
                    index++; // skip '('

                    // Check for negation
                    if (formula[index] === '~') {
                        index++;
                        const node = new Node('~');
                        node.left = parse();
                        if (formula[index] !== ')') throw new Error('Expected )');
                        index++;
                        return node;
                    }

                    // Parse left operand
                    const left = parse();

                    // Check for binary operator
                    if (['+', '*', '>'].includes(formula[index])) {
                        const op = formula[index];
                        index++;
                        const right = parse();
                        if (formula[index] !== ')') throw new Error('Expected )');
                        index++;
                        return new Node(op, left, right);
                    }

                    if (formula[index] !== ')') throw new Error('Expected )');
                    index++;
                    return left;
                }

                // Variable
                if (/[a-zA-Z]/.test(formula[index])) {
                    return new Node(formula[index++]);
                }

                throw new Error('Unexpected character: ' + formula[index]);
            }

            const tree = parse();
            if (index < formula.length) {
                throw new Error('Unexpected characters after formula');
            }
            return tree;
        }

        // Convert tree to infix
        function toInfix(node) {
            if (!node) return '';
            if (node.isLeaf()) return node.value;
            if (node.value === '~') return '(~' + toInfix(node.left) + ')';
            return '(' + toInfix(node.left) + node.value + toInfix(node.right) + ')';
        }

        // Convert tree to prefix
        function toPrefix(node) {
            if (!node) return '';
            let result = node.value;
            if (node.left) result += ' ' + toPrefix(node.left);
            if (node.right) result += ' ' + toPrefix(node.right);
            return result;
        }

        // Tree structure
        function treeStructure(node, indent = 0) {
            if (!node) return '';
            let result = '  '.repeat(indent) + node.value + '\n';
            if (node.left) result += treeStructure(node.left, indent + 1);
            if (node.right) result += treeStructure(node.right, indent + 1);
            return result;
        }

        // Tree height
        function treeHeight(node) {
            if (!node) return -1;
            return 1 + Math.max(treeHeight(node.left), treeHeight(node.right));
        }

        // Extract variables
        function extractVariables(node, vars = new Set()) {
            if (!node) return vars;
            if (node.isLeaf()) vars.add(node.value);
            extractVariables(node.left, vars);
            extractVariables(node.right, vars);
            return vars;
        }

        // Evaluate tree
        function evaluate(node, assignments) {
            if (!node) return false;
            if (node.isLeaf()) return assignments[node.value] || false;

            switch (node.value) {
                case '~': return !evaluate(node.left, assignments);
                case '+': return evaluate(node.left, assignments) || evaluate(node.right, assignments);
                case '*': return evaluate(node.left, assignments) && evaluate(node.right, assignments);
                case '>': return !evaluate(node.left, assignments) || evaluate(node.right, assignments);
                default: return false;
            }
        }

        // CNF Conversion
        function convertTreeToCNF(node) {
            node = eliminateImplications(node);
            node = moveNegationsInward(node);
            node = distributeOrOverAnd(node);
            return node;
        }

        function eliminateImplications(node) {
            if (!node) return null;
            node.left = eliminateImplications(node.left);
            node.right = eliminateImplications(node.right);
            if (node.value === '>') {
                return new Node('+', new Node('~', node.left), node.right);
            }
            return node;
        }

        function moveNegationsInward(node) {
            if (!node) return null;

            if (node.value === '~') {
                const child = node.left;
                if (child.value === '~') return moveNegationsInward(child.left);
                if (child.value === '+') {
                    return moveNegationsInward(new Node('*',
                        new Node('~', child.left),
                        new Node('~', child.right)
                    ));
                }
                if (child.value === '*') {
                    return moveNegationsInward(new Node('+',
                        new Node('~', child.left),
                        new Node('~', child.right)
                    ));
                }
            }

            node.left = moveNegationsInward(node.left);
            node.right = moveNegationsInward(node.right);
            return node;
        }

        function distributeOrOverAnd(node) {
            if (!node) return null;
            node.left = distributeOrOverAnd(node.left);
            node.right = distributeOrOverAnd(node.right);

            if (node.value === '+') {
                if (node.left?.value === '*') {
                    return distributeOrOverAnd(new Node('*',
                        new Node('+', node.left.left, node.right.clone()),
                        new Node('+', node.left.right, node.right.clone())
                    ));
                }
                if (node.right?.value === '*') {
                    return distributeOrOverAnd(new Node('*',
                        new Node('+', node.left.clone(), node.right.left),
                        new Node('+', node.left.clone(), node.right.right)
                    ));
                }
            }
            return node;
        }

        // Extract clauses for DIMACS
        function extractClauses(node) {
            const clauses = [];

            function extract(n) {
                if (!n) return;
                if (n.value === '*') {
                    extract(n.left);
                    extract(n.right);
                } else {
                    const literals = [];
                    extractLiterals(n, literals);
                    if (literals.length > 0) clauses.push(literals);
                }
            }

            function extractLiterals(n, literals) {
                if (!n) return;
                if (n.value === '+') {
                    extractLiterals(n.left, literals);
                    extractLiterals(n.right, literals);
                } else if (n.value === '~') {
                    const varName = n.left.value;
                    if (!variableMapping[varName]) {
                        variableMapping[varName] = nextVarId;
                        reverseMapping[nextVarId] = varName;
                        nextVarId++;
                    }
                    literals.push(-variableMapping[varName]);
                } else if (n.isLeaf()) {
                    const varName = n.value;
                    if (!variableMapping[varName]) {
                        variableMapping[varName] = nextVarId;
                        reverseMapping[nextVarId] = varName;
                        nextVarId++;
                    }
                    literals.push(variableMapping[varName]);
                }
            }

            extract(node);
            return clauses;
        }

        // UI Functions
        function showOutput(id, text, type = 'info') {
            const el = document.getElementById(id);
            el.textContent = text;
            el.className = 'output ' + type;
        }

        function loadExample(formula) {
            document.getElementById('infixInput').value = formula;
            buildTree();
        }

        function buildTree() {
            const infix = document.getElementById('infixInput').value.trim();
            if (!infix) {
                showOutput('output', 'Please enter a formula', 'error');
                return;
            }

            try {
                currentTree = parseInfix(infix);
                showOutput('output',
                    '✓ Parse tree built successfully!\n\n' +
                    'Infix: ' + toInfix(currentTree) + '\n' +
                    'Prefix: ' + toPrefix(currentTree),
                    'output'
                );
                updateEvalInputs();
            } catch (e) {
                showOutput('output', '✗ Error: ' + e.message, 'error');
            }
        }

        function convertToPrefix() {
            const infix = document.getElementById('infixInput').value.trim();
            if (!infix) {
                showOutput('output', 'Please enter a formula', 'error');
                return;
            }

            try {
                const tree = parseInfix(infix);
                showOutput('output',
                    '✓ Conversion complete!\n\n' +
                    'Infix: ' + infix + '\n' +
                    'Prefix: ' + toPrefix(tree),
                    'output'
                );
            } catch (e) {
                showOutput('output', '✗ Error: ' + e.message, 'error');
            }
        }

        function showInfix() {
            if (!currentTree) {
                showOutput('treeOutput', 'Build a tree first', 'error');
                return;
            }
            showOutput('treeOutput', 'Infix: ' + toInfix(currentTree), 'output');
        }

        function showPrefix() {
            if (!currentTree) {
                showOutput('treeOutput', 'Build a tree first', 'error');
                return;
            }
            showOutput('treeOutput', 'Prefix: ' + toPrefix(currentTree), 'output');
        }

        function showHeight() {
            if (!currentTree) {
                showOutput('treeOutput', 'Build a tree first', 'error');
                return;
            }
            showOutput('treeOutput', 'Tree Height: ' + treeHeight(currentTree), 'output');
        }

        function showStructure() {
            if (!currentTree) {
                showOutput('treeOutput', 'Build a tree first', 'error');
                return;
            }
            showOutput('treeOutput', 'Tree Structure:\n\n' + treeStructure(currentTree), 'output');
        }

        function convertToCNF() {
            if (!currentTree) {
                showOutput('cnfOutput', 'Build a tree first', 'error');
                return;
            }

            try {
                currentCNFTree = convertTreeToCNF(currentTree.clone());
                showOutput('cnfOutput',
                    '✓ CNF Conversion Complete!\n\n' +
                    'Original: ' + toInfix(currentTree) + '\n\n' +
                    'CNF: ' + toInfix(currentCNFTree),
                    'output'
                );
            } catch (e) {
                showOutput('cnfOutput', '✗ Error: ' + e.message, 'error');
            }
        }

        function checkValidity() {
            if (!currentTree) {
                showOutput('cnfOutput', 'Build a tree first', 'error');
                return;
            }

            try {
                const tree = currentCNFTree || convertTreeToCNF(currentTree.clone());

                variableMapping = {};
                reverseMapping = {};
                nextVarId = 1;

                const clauses = extractClauses(tree);
                let isValid = true;
                let output = 'Validity Check:\n\n';

                for (let i = 0; i < clauses.length; i++) {
                    const clause = clauses[i];
                    let hasComplement = false;

                    for (let j = 0; j < clause.length; j++) {
                        for (let k = j + 1; k < clause.length; k++) {
                            if (clause[j] === -clause[k]) {
                                hasComplement = true;
                                break;
                            }
                        }
                    }

                    output += 'Clause ' + (i + 1) + ': ' +
                        clause.map(lit => (lit > 0 ? '' : '¬') + reverseMapping[Math.abs(lit)]).join(' ∨ ') +
                        ' → ' + (hasComplement ? '✓ Valid' : '✗ Not valid') + '\n';

                    if (!hasComplement) isValid = false;
                }

                output += '\n' + (isValid ? '✓ Formula is VALID' : '✗ Formula is NOT VALID');
                showOutput('cnfOutput', output, isValid ? 'output' : 'error');
            } catch (e) {
                showOutput('cnfOutput', '✗ Error: ' + e.message, 'error');
            }
        }

        function updateEvalInputs() {
            if (!currentTree) return;

            const vars = Array.from(extractVariables(currentTree)).sort();
            let html = '';

            vars.forEach(v => {
                html += `<label>${v}: <select id="eval_${v}">
                    <option value="true">True</option>
                    <option value="false">False</option>
                </select></label> `;
            });

            document.getElementById('evalInputs').innerHTML = html;
            showOutput('evalOutput', 'Set values and click Evaluate', 'info');
        }

        function evaluateFormula() {
            if (!currentTree) {
                showOutput('evalOutput', 'Build a tree first', 'error');
                return;
            }

            const assignments = {};
            const vars = Array.from(extractVariables(currentTree));

            vars.forEach(v => {
                const sel = document.getElementById('eval_' + v);
                if (sel) assignments[v] = sel.value === 'true';
            });

            const result = evaluate(currentTree, assignments);
            let output = 'Evaluation Result:\n\n';
            output += 'Formula: ' + toInfix(currentTree) + '\n\n';
            output += 'Assignments:\n';
            for (let v in assignments) {
                output += '  ' + v + ' = ' + assignments[v] + '\n';
            }
            output += '\nResult: ' + result;

            showOutput('evalOutput', output, 'output');
        }

        function convertToDIMACS() {
            if (!currentTree) {
                showOutput('dimacsOutput', 'Build a tree first', 'error');
                return;
            }

            try {
                const tree = currentCNFTree || convertTreeToCNF(currentTree.clone());

                variableMapping = {};
                reverseMapping = {};
                nextVarId = 1;

                const clauses = extractClauses(tree);
                const numVars = Object.keys(variableMapping).length;

                let dimacs = 'p cnf ' + numVars + ' ' + clauses.length + '\n';
                clauses.forEach(clause => {
                    dimacs += clause.join(' ') + ' 0\n';
                });

                let output = '✓ DIMACS Conversion:\n\n' + dimacs + '\nMapping:\n';
                Object.keys(variableMapping).sort().forEach(v => {
                    output += v + ' → ' + variableMapping[v] + '\n';
                });

                showOutput('dimacsOutput', output, 'output');
                window.currentDIMACS = dimacs;
            } catch (e) {
                showOutput('dimacsOutput', '✗ Error: ' + e.message, 'error');
            }
        }

        function downloadDIMACS() {
            if (!window.currentDIMACS) {
                showOutput('dimacsOutput', 'Convert to DIMACS first', 'error');
                return;
            }

            const blob = new Blob([window.currentDIMACS], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'formula.cnf';
            a.click();
            URL.revokeObjectURL(url);

            showOutput('dimacsOutput', '✓ File downloaded!', 'output');
        }

        function parseDIMACS() {
            const content = document.getElementById('dimacsInput').value.trim();
            if (!content) {
                showOutput('dimacsOutput', 'Enter DIMACS content', 'error');
                return;
            }

            try {
                const lines = content.split('\n');
                let numVars = 0, numClauses = 0;
                const clauses = [];

                variableMapping = {};
                reverseMapping = {};

                lines.forEach(line => {
                    line = line.trim();
                    if (!line || line.startsWith('c')) return;

                    if (line.startsWith('p')) {
                        const parts = line.split(/\s+/);
                        numVars = parseInt(parts[2]);
                        numClauses = parseInt(parts[3]);

                        const chineseChars = 'abcdefghijklmnopqrstuvwxyz';

                        for (let i = 1; i <= numVars; i++) {
                            let varName;
                            if (i <= chineseChars.length) {
                                varName = chineseChars[i - 1];
                            } else {
                                const base = chineseChars[(i - 1) % chineseChars.length];
                                const num = Math.floor((i - 1) / chineseChars.length);
                                varName = base + num;
                            }
                            variableMapping[varName] = i;
                            reverseMapping[i] = varName;
                        }
                        return;
                    }

                    const literals = line.split(/\s+/).filter(x => x && x !== '0').map(x => parseInt(x));
                    if (literals.length > 0) clauses.push(literals);
                });

                let output = '✓ DIMACS Parsed:\n\n';
                output += 'Variables: ' + numVars + '\n';
                output += 'Clauses: ' + numClauses + '\n\n';

                clauses.forEach((clause, i) => {
                    const clauseStr = clause.map(lit =>
                        (lit > 0 ? '' : '¬') + reverseMapping[Math.abs(lit)]
                    ).join(' ∨ ');
                    output += (i + 1) + '. (' + clauseStr + ')\n';
                });

                showOutput('dimacsOutput', output, 'output');
            } catch (e) {
                showOutput('dimacsOutput', '✗ Error: ' + e.message, 'error');
            }
        }

        function checkDIMACSValidity() {
            const content = document.getElementById('dimacsInput').value.trim();
            if (!content) {
                showOutput('dimacsOutput', 'Enter DIMACS content first', 'error');
                return;
            }

            try {
                const lines = content.split('\n');
                const clauses = [];
                variableMapping = {};
                reverseMapping = {};

                lines.forEach(line => {
                    line = line.trim();
                    if (!line || line.startsWith('c')) return;

                    if (line.startsWith('p')) {
                        const parts = line.split(/\s+/);
                        const numVars = parseInt(parts[2]);

                        const chineseChars = 'abcdefghijklmnopqrstuvwxyz';

                        for (let i = 1; i <= numVars; i++) {
                            let varName;
                            if (i <= chineseChars.length) {
                                varName = chineseChars[i - 1];
                            } else {
                                const base = chineseChars[(i - 1) % chineseChars.length];
                                const num = Math.floor((i - 1) / chineseChars.length);
                                varName = base + num;
                            }
                            variableMapping[varName] = i;
                            reverseMapping[i] = varName;
                        }
                        return;
                    }

                    const literals = line.split(/\s+/).filter(x => x && x !== '0').map(x => parseInt(x));
                    if (literals.length > 0) clauses.push(literals);
                });

                let isValid = true;
                let output = 'DIMACS Validity Check:\n\n';

                clauses.forEach((clause, i) => {
                    let hasComplement = false;
                    for (let j = 0; j < clause.length; j++) {
                        for (let k = j + 1; k < clause.length; k++) {
                            if (clause[j] === -clause[k]) {
                                hasComplement = true;
                                break;
                            }
                        }
                    }

                    const clauseStr = clause.map(lit =>
                        (lit > 0 ? '' : '¬') + reverseMapping[Math.abs(lit)]
                    ).join(' ∨ ');

                    output += 'Clause ' + (i + 1) + ': (' + clauseStr + ') → ' +
                        (hasComplement ? '✓ Valid' : '✗ Not valid') + '\n';

                    if (!hasComplement) isValid = false;
                });

                output += '\n' + (isValid ? '✓ DIMACS is VALID' : '✗ DIMACS is NOT VALID');
                showOutput('dimacsOutput', output, isValid ? 'output' : 'error');
            } catch (e) {
                showOutput('dimacsOutput', '✗ Error: ' + e.message, 'error');
            }
        }

        function printTruthTable() {
            if (!currentTree) {
                showOutput('evalOutput', 'Build a tree first', 'error');
                return;
            }

            try {
                const vars = Array.from(extractVariables(currentTree)).sort();
                const numVars = vars.length;
                const totalRows = Math.pow(2, numVars);

                let table = 'Truth Table for: ' + toInfix(currentTree) + '\n\n';

                // Header
                table += vars.join('\t') + '\tResult\n';
                table += '-'.repeat(vars.length * 8 + 8) + '\n';

                // Generate all combinations
                for (let row = 0; row < totalRows; row++) {
                    const assignments = {};
                    let rowStr = '';

                    // Generate truth values for this row
                    for (let v = 0; v < numVars; v++) {
                        const value = (row & (1 << (numVars - 1 - v))) !== 0;
                        assignments[vars[v]] = value;
                        rowStr += (value ? 'T' : 'F') + '\t';
                    }

                    // Evaluate formula with these assignments
                    const result = evaluate(currentTree, assignments);
                    rowStr += (result ? 'T' : 'F') + '\n';
                    table += rowStr;
                }

                showOutput('evalOutput', table, 'output');
            } catch (e) {
                showOutput('evalOutput', '✗ Error: ' + e.message, 'error');
            }
        }
        function dimacsToInfix() {
            const content = document.getElementById('dimacsInput').value.trim();
            if (!content) {
                showOutput('dimacsOutput', 'Enter DIMACS content first', 'error');
                return;
            }

            try {
                const lines = content.split('\n');
                const clauses = [];
                variableMapping = {};
                reverseMapping = {};

                lines.forEach(line => {
                    line = line.trim();
                    if (!line || line.startsWith('c')) return;

                    if (line.startsWith('p')) {
                const parts = line.split(/\s+/);
                const numVars = parseInt(parts[2]);
                
                const chineseChars = 'abcdefghijklmnopqrstuvwxyz';
                
                for (let i = 1; i <= numVars; i++) {
                    let varName;
                    if (i <= chineseChars.length) {
                        varName = chineseChars[i - 1];
                    } else {
                        const base = chineseChars[(i - 1) % chineseChars.length];
                        const num = Math.floor((i - 1) / chineseChars.length);
                        varName = base + num;
                    }
                    variableMapping[varName] = i;
                    reverseMapping[i] = varName;
                }
                return;
            }

                    const literals = line.split(/\s+/).filter(x => x && x !== '0').map(x => parseInt(x));
                    if (literals.length > 0) clauses.push(literals);
                });

                if (clauses.length === 0) {
                    showOutput('dimacsOutput', 'No clauses found', 'error');
                    return;
                }

                // Convert each clause to a tree node (disjunction of literals)
                // Convert each clause to a tree node (disjunction of literals)
                function clauseToNode(clause) {
                    if (clause.length === 1) {
                        const lit = clause[0];
                        const varName = reverseMapping[Math.abs(lit)];
                        if (lit < 0) {
                            return new Node('~', new Node(varName));
                        }
                        return new Node(varName);
                    }

                    // Build OR tree from literals - properly structured
                    const literals = clause.map(lit => {
                        const varName = reverseMapping[Math.abs(lit)];
                        return lit < 0 ? new Node('~', new Node(varName)) : new Node(varName);
                    });

                    // Build balanced OR tree
                    let node = literals[0];
                    for (let i = 1; i < literals.length; i++) {
                        node = new Node('+', node, literals[i]);
                    }
                    return node;
                }

                // Build CNF tree (conjunction of clauses)
                // Build CNF tree (conjunction of clauses)
                const clauseNodes = clauses.map(clause => clauseToNode(clause));

                let cnfTree = clauseNodes[0];
                for (let i = 1; i < clauseNodes.length; i++) {
                    cnfTree = new Node('*', cnfTree, clauseNodes[i]);
                }

                const infixFormula = toInfix(cnfTree);

                let output = '✓ DIMACS to Infix Conversion:\n\n';
                output += 'Infix Formula:\n' + infixFormula + '\n\n';
                output += 'Variable Mapping:\n';
                Object.keys(variableMapping).sort().forEach(v => {
                    output += v + ' ↔ ' + variableMapping[v] + '\n';
                });

                showOutput('dimacsOutput', output, 'output');

                // Update the infix input field
                document.getElementById('infixInput').value = infixFormula;

            } catch (e) {
                showOutput('dimacsOutput', '✗ Error: ' + e.message, 'error');
            }
        }
    </script>

</body>

</html>