<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>parseOperand Function Explanation</title>
    <link rel="stylesheet" href="../style.css">
</head>

<body>
    <div class="container">
        <div class="chapter-content">
            <h1>Detailed Explanation: <code>parseOperand</code> Function</h1>

            <pre><code>Node* parseOperand(char* formula) {
    if (index_pos >= strlen(formula)) {
        return NULL;
    }
    
    if (formula[index_pos] == '(') {
        return parseExpression(formula);
    }
    
    if (formula[index_pos] == '~') {
        return parseExpression(formula);
    }
    
    char var = formula[index_pos];
    index_pos++;
    return createNode(var);
}
</code></pre>

            <ul>
                <li>
                    <b>Line 1:</b><br>
                    <code>Node* parseOperand(char* formula)</code>:
                    Declares a function that takes a string <code>formula</code> and returns a pointer to a
                    <code>Node</code>.
                    This function is intended to parse either a variable or a subexpression from the input formula.
                </li>
                <li>
                    <b>Line 2-4:</b><br>
                    <code>if (index_pos >= strlen(formula)) { return NULL; }</code>
                    Checks if the current position (<code>index_pos</code>) has reached or passed the end of the input
                    string.
                    If so, it returns <code>NULL</code> indicating no more operands.
                </li>
                <li>
                    <b>Line 6-8:</b><br>
                    <code>if (formula[index_pos] == '(') { return parseExpression(formula); }</code>
                    If the current character is an opening parenthesis <code>'('</code>, this signals the start of a
                    subexpression.
                    The function calls <code>parseExpression</code> to process the entire subexpression and returns its
                    syntax tree root.
                </li>
                <li>
                    <b>Line 10-12:</b><br>
                    <code>if (formula[index_pos] == '~') { return parseExpression(formula); }</code>
                    If the current character is a NOT operator <code>'~'</code>, the function treats it as a unary
                    subexpression and calls <code>parseExpression</code> to handle it.
                </li>
                <li>
                    <b>Line 14-16:</b><br>
                    <code>char var = formula[index_pos]; index_pos++; return createNode(var);</code>
                    - Reads the current character from the input (assumed to be a variable like 'A', 'P', etc.).
                    - Advances the global <code>index_pos</code> to the next character for further parsing.
                    - Calls <code>createNode(var)</code>, which allocates memory for a new <code>Node</code>
                    representing that variable, and returns the pointer.
                </li>
            </ul>

            <hr>

            <h2>Key Concepts:</h2>
            <div class="insight-box">
                <ul>
                    <li><b>Parsing flow:</b> This function is often used in recursive descent parsing, where operands
                        might be variables or sub-expressions.</li>
                    <li><b>Memory allocation:</b> Each variable node is created on the heap using the
                        <code>createNode</code> function (which internally uses <code>malloc</code>). Returned pointers
                        must eventually be freed to avoid memory leaks.
                    </li>
                    <li><b>Global index:</b> <code>index_pos</code> keeps track of the current parsing position in the
                        formula, ensuring sequential processing.</li>
                    <li><b>NULL return:</b> Protects against accessing invalid memory when the end of the formula string
                        is reached.</li>
                </ul>
            </div>
        </div>
    </div>
</body>

</html>