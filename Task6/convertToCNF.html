<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convert to CNF Function Explanation</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="chapter-content">
        <h1>Explanation: <code>convertToCNF</code> Function</h1>

        <pre><code>Node *convertToCNF(Node *root)
{
    if (root == NULL)
        return NULL;

    root = eliminateImplications(root);
    root = moveNegationsInward(root);
    root = distributeOrOverAnd(root);

    return root;
}
</code></pre>

        <ul>
          <li>
            <b>Function Purpose:</b><br>
            Converts a logical formula (represented as a parse tree) into Conjunctive Normal Form (CNF). It applies a sequence of standard transformations: eliminating implications, moving negations inward, and distributing OR over AND.
          </li>
        </ul>

        <h2>Line-by-Line Explanation</h2>
        <ul>
          <li>
            <code>if (root == NULL) return NULL;</code><br>
            Base case: if the tree is empty, return <code>NULL</code>.
          </li>
          <li>
            <code>root = eliminateImplications(root);</code><br>
            Replaces all implications (<code>></code>) in the tree with their equivalent expressions, such as <code>~A + B</code>.
          </li>
          <li>
            <code>root = moveNegationsInward(root);</code><br>
            Pushes negations as deep inward as possible, applying De Morgan's laws. This step simplifies the formula to Negation Normal Form (NNF).
          </li>
          <li>
            <code>root = distributeOrOverAnd(root);</code><br>
            Applies the distributive law to move OR operators down over ANDs, resulting in a conjunction of disjunctions (CNF form).
          </li>
          <li>
            <code>return root;</code><br>
            Returns the root of the transformed parse tree, now in CNF.
          </li>
        </ul>

        <h2>Key Concepts</h2>
        <ul>
          <li><b>Sequential Transformation:</b> The function performs stepwise transformation towards CNF, crucial in automated theorem proving and SAT solving.</li>
          <li><b>Recursion:</b> All helper functions are recursive, ensuring thorough processing of all subtrees.</li>
          <li><b>Memory Management:</b> Each transformation updates the tree structure safely, and the previous nodes are replaced by new nodes as needed.</li>
          <li><b>Tree Manipulation:</b> Combines standard logical equivalences with recursive tree operations for systematic normalization.</li>
        </ul>

        <h2>Example Usage</h2>
        <pre><code>// Convert a formula `(A > B) * (C + D)` into CNF
Node* root = buildParseTree(" (A>B) * (C+D) ");
root = convertToCNF(root);
// Now root represents the formula in CNF form
</code></pre>
    </div>
</body>
</html>
